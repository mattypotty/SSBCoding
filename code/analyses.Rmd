---
title: "SSB Analyses"
author: "Matthew Pottinger & Sarah Swiston"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    theme: cerulean
---

# {.tabset .tabset-pills}

<!--
#####################################################################
#####################################################################
SETUP: MARKDOWN, PACKAGES, DIRECTORIES, PLOT SETTINGS, & READING DATA
#####################################################################
#####################################################################
-->

## Setup

This project is about same-sex sexual behavior (SSB) in mammals. It has previously been demonstrated that SSB has developed numerous times across the mammal phylogeny (Gómez et al. 2023), but the underlying patterns behind where and why SSB evolves remains largely unknown. This work serves to compare existing phylogenetic data for SSB's presence with that of other covariates, with the purpose of investigating potential ties between SSB and mammal sociality, maternal investment, confusion, diversification, and extinction. We approached our analysis of SSB under the traditional assumptions of the field, namely that SSB, as an energy intensive but reproductively unfruitful, is a largely nonadaptive or maladaptive trait. To test this, we broke our analysis into three primary sections: maternal investment, designed to investigate the energy costs involved in engaging in nonreproductive sexual behavior, sociality, designed to investigate at a deeper level previously established ties between social behavior and SSB, and confusion and maladaptation, designed test theories that posit SSB existing as rendering no fitness benefit. ANALYSES METHODS DETAILS HERE. The details of each category of study and individual hypotheses can be found below:

```{r setup, echo=FALSE}
# R markdown is used to create documents (in this case, an HTML document) out of R code and output
# Code is in "chunks" that can be run, everything else is text
# This code chunk sets up how the HTML file will be created from this markdown document when we "knit" it
# By default, we want no code to run, no code to be shown, and no output to be shown
# Then for each code chunk, we will decide whether to run it, show it, and show its results

knitr::opts_chunk$set(eval=FALSE,echo=FALSE,results=FALSE,message=FALSE,warning=FALSE,tidy='styler')
# eval    - whether the code will be run (evaluated) when we create our HTML file
# echo    - whether the code will be shown (printed) when we create our HTML file
# results - whether the results of the code will be shown (printed) when we create our HTML file
# message - whether the messages output by R will be shown (printed) when we create our HTML file
# warning - whether the warnings output by R will be shown (printed) when we create our HTML file
```

```{r packages, eval=TRUE}
# Some functions are available in base R without installing any packages
# However, packages (which are built by outside individuals) provide additional functions
# All of the packages for this project are accessible on CRAN, a repository run by the R dev team
# This code chunk is for loading different packages so we can access their functions
# Note that we want to run this code (eval=TRUE) but we don't need to show it in our document
print("Loading packages...",quote=F)

library(this.path) # This package lets us get the filepath of the script we are running
library(ape) # Used for handling trees
library(phangorn) # Used for making MCC (maximum clade credibility) tree from posterior of trees
library(castor) # Used for checking if tree is bifurcating
library(caper) # Used for phylogenetic signal (d) analyses
library(phytools) # Used for plotting trees
library(diversitree) # Used for SSE analyses
library(MCMCglmm) # Used for MCMCglmm analyses
library(coda) # Used for analyzing MCMC output
library(MCMCvis) # Used for analyzing MCMC output
library(mcmcr) # Used for analyzing MCMC output
library(styler) # For knitting
```

```{r directories, eval=TRUE}
# This code chunk sets the working directory for the analyses and creates some file paths for saving output
# This can be done by hand too:
# clicking session > setting working directory > to source file location

setwd(this.path::here()) # Sets the working directory to the main SSB folder (using the "this.path" package)
print(paste0("Working directory: ",getwd()),quote=F)
```

```{r analysis_settings, eval=TRUE}
# We will use ALL CAPS for our analysis settings
# This way, we can look at a variable and know it is a setting
print("Setting up analysis...",quote=F)

USEGLOBAL <- FALSE

args <- commandArgs(trailingOnly = TRUE)
print("Input arguments:",quote=F)
print(args)
if (!identical(args,character(0))) {
  USEGLOBAL <- TRUE
  .NUMBER <<- args[1]
  .USERANDOM <<- args[2]
  .ANALYSIS <<- args[3]
  .SSBTYPE <<- args[4]
  .HYPOTHESIS <<- args[5]
  .VARIABLE <<- args[6]
}

# We'll use the variable USEGLOBAL to indicate whether we want to use inputs from shell script
set_global <- function() {
  if (exists(".NUMBER")) {NUMBER <- .NUMBER}
  if (exists(".ANALYSIS")) {ANALYSIS <- .ANALYSIS}
  if (exists(".SSBTYPE")) {SSBTYPE <- .SSBTYPE}
  if (exists(".HYPOTHESIS")) {HYPOTHESIS <- .HYPOTHESIS}
  if (exists(".VARIABLE")) {VARIABLE <- .VARIABLE}
  if (exists(".USERANDOM")) {USERANDOM <- .USERANDOM}
}

if (USEGLOBAL) {set_global()}

if (!exists("NUMBER")) {NUMBER <- 1} # Allows us to run multiple analyses of the same type, each with a different number
set.seed(NUMBER) # For analyses requiring random numbers, we might want the same output every time

if (!exists("USERANDOM")) {USERANDOM <- FALSE} # Whether we use a random tree from the set instead of the MCC tree
# OPTIONS: FALSE, TRUE

if (!exists("ANALYSIS")) {ANALYSIS <- "NONE"}
# OPTIONS: "NONE", "MCCTREE", "SPECMATS", "MCMCGLMM", "PAGEL"

if (!exists("SSBTYPE")) {SSBTYPE <- "NONE"}
# OPTIONS: "NONE", "SSB", "FSSB", "MSSB"

if (!exists("HYPOTHESIS")) {HYPOTHESIS <- "NONE"}
# OPTIONS: "NONE", "MI", "MGS", "SDT", "RDM", "AM", "IUCN"

if (!exists("VARIABLE")) {VARIABLE <- "NONE"}
# OPTIONS: "NONE", "NAC", "SPI", "TSP", "SDT", "RDM"

# MCMC Settings
NITT <- 100000 # 100,000
BURNIN <- 10000 # 10,000
THIN <- 100 # 100
prior <- list(G=list(G1=list(V=1,nu=0.02)),
              R=list(V=1,nu=0.02))
```

Making things into functions so we don't have to rewrite so much code

```{r do_mcmc, echo=TRUE, eval=TRUE}
do_mcmc <- function(f) {
  # File names
  analysis_name <- paste0(ANALYSIS,"_",SSBTYPE,"_",HYPOTHESIS,"_",tree_number,"_",NUMBER)
  print(paste0("Performing analysis: ",analysis_name),quote=F)
  out_file <- paste0("../output/",analysis_name,".log.csv")
  summary_file <- paste0("../output/",analysis_name,".sum.txt")
  
  #Read in data
  columns <- c("Species",all.vars(f))
  data_subset <- data[,columns]
  # Removes incomplete cases
  data_subset <- data_subset[complete.cases(data_subset),]
  
  # Running MCMCglmm
  MCMCanalysis <- MCMCglmm::MCMCglmm(f,
                  random = ~Species,
                  family = "categorical",
                  ginverse = list(Species=inv.phylo),
                  prior = prior,
                  data = data_subset,
                  nitt = NITT,
                  burnin = BURNIN,
                  thin = THIN,
                  verbose = TRUE)
  
  write.csv(MCMCanalysis$Sol,out_file,row.names=FALSE,quote=FALSE)
  out <- capture.output(cat(paste0("ESS: ",ess(MCMCanalysis$Sol),"\n")),
                        print(summary(MCMCanalysis$Sol)))
  write(out,summary_file)
}
```

```{r do_pagel, echo=TRUE, eval=TRUE}
do_pagel <- function() {
  # File names
  analysis_name <- paste0(ANALYSIS,"_",SSBTYPE,"_",VARIABLE,"_",tree_number,"_",NUMBER)
  print(paste0("Performing analysis: ",analysis_name),quote=F)
  summary_file <- paste0("../output/",analysis_name,".sum.txt")
  
  #Read in data
  columns <- c("Species",SSBTYPE,VARIABLE)
  data_subset <- data[,columns]
  # Removes incomplete cases
  data_subset <- data_subset[complete.cases(data_subset),]
  phy_subset <- ape::keep.tip(phy, data_subset$Species)
  
  #Assign species names
  SSB <- setNames(data_subset[[SSBTYPE]],data_subset$Species)
  VAR <- setNames(data_subset[[VARIABLE]],data_subset$Species)
  
  write(paste0("Pagel's Directional Test for ",SSBTYPE," and ",VARIABLE),summary_file)
  write("--------------------",summary_file,append=TRUE)

  # Fit models where SSB and NAC are totally independent or dependent
  fit_SSB_VAR <- phytools::fitPagel(phy_subset,SSB,VAR)
  out1 <- capture.output(print(fit_SSB_VAR))
  write(paste0("Both Independent or Dependent"),summary_file,append=TRUE)
  write(out1,summary_file,append=TRUE)
  write("--------------------",summary_file,append=TRUE)
  
  # Fit model where SSB depends on NAC
  fit_SSB <- phytools::fitPagel(phy_subset,SSB,VAR,dep.var="x")
  out2 <- capture.output(print(fit_SSB))
  write(paste0("Dependent ",SSBTYPE),summary_file,append=TRUE)
  write(out2,summary_file,append=TRUE)
  write("--------------------",summary_file,append=TRUE)
  
  # Fit model where NAC depends on SSB
  fit_VAR <- phytools::fitPagel(phy_subset,SSB,VAR,dep.var="y")
  out3 <- capture.output(print(fit_VAR))
  write(paste0("Dependent ",VARIABLE),summary_file,append=TRUE)
  write(out3,summary_file,append=TRUE)
  write("--------------------",summary_file,append=TRUE)
  
  # Comparing the goodness of all 4 models using AIC
  aic <- setNames(c(fit_SSB_VAR$independent.AIC,
                    fit_SSB$dependent.AIC,
                    fit_VAR$dependent.AIC,
                    fit_SSB_VAR$dependent.AIC),
                  c("independent","dependent SSB",paste0("dependent ",VARIABLE),paste0("dependent SSB & ",VARIABLE)))
  out4 <- capture.output(print(aic))
  out5 <- capture.output(print(aic.w(aic)))
  write(paste0("AIC"),summary_file,append=TRUE)
  write(out4,summary_file,append=TRUE)
  write(paste0("Weights"),summary_file,append=TRUE)
  write(out5,summary_file,append=TRUE)
}
```

## Dataset

DESCRIPTION OF DATASET HERE

Data Cleaning:

The species list used in this analysis was updated to fit with Phylacine 1.2 from Gómez et al.’s subset 4 and 1 for the character trait and diversification-extinction analyses, respectively. Discrepancies between the two data sets were evaluated using the American Society of Mammalogists’ Mammal Diversity Database, with the most up to date taxonomy being applied (Supplemental table for name changes to 1700). During those discrepancies, if Phylacine 1.2’s taxonomy did not reflect that of the Mammal Diversity Database, note of it was added to the R analysis so that it could be automatically changed during phylogeny reading, but still maintained as the most accurate form in our dataset (Supplemental table for dataset to phylogeny changes). In cases of species that had been duplicated or are now included under other taxa, if SSB was present for said duplicate or inclusion, it was listed as present for the final dataset. 

NLV = No Longer Valid. Includes all species removed from analysis. 

```{r dataset, eval=TRUE, results="SHOW"}
# This code chunk reads in our data files
# Note that we want to run this code (eval=TRUE) and show the output (results="SHOW"), but we don't need to see it
print("Reading in data...",quote=F)

data_file <- read.csv("../data/FINALdata_20251124.csv", header = TRUE, sep = ",") # Reads the data, which is a csv file (comma separated values), and saves to "data" variable
#print(data_file$Column.Name.Key[data_file$Column.Name.Key != ""]) # Prints the column name key
#print(data_file$Mating.Group.Structures.Key[data_file$Mating.Group.Structures.Key != ""]) # prints the group mating structures key

data_full <- data.frame(data_file[,-which(colnames(data_file)=="Column.Name.Key" | colnames(data_file)=="Mating.Group.Structures.Key")]) # Removing keys from dataset

# Fixing any problems with the dataset
data_full$Species[which(data_full$Species=="Otaria flavescens")] <- "Otaria_flavescens"

# Removing species which are not in the tree
phylogeny_changes <- read.csv("../data/Dataset_to_Phylogeny_Changes.csv", header = TRUE, sep = ",")[,1:2]
for (i in 1:nrow(phylogeny_changes)) {
  if (phylogeny_changes$Name.used.for.Phylacine[i] == "NLV") {
    name <- phylogeny_changes$X1700.Species.Name[i]
    data_full <- data_full[data_full$Species != name,]
  }
}

SOC <- rep(NA,nrow(data_full))
for (i in 1:nrow(data_full)) {
  if (data_full$GL[i] == "N") {SOC[i] <- "SOL"}
  if (data_full$GL[i] == "Y") {SOC[i] <- "GL"}
  if (data_full$SOG[i] == "Y") {SOC[i] <- "SOG"}
}
data_full$SOC <- SOC

quantitative <- c("GP","BM","AFM","MR","PC","FWA","FAM","MAM") # quantitative columns
binary <- c("RDM","TSP","NB","SDT","GL","SPI","NAC","GIM","GFE","MMC","BG","DHE","DCA","DPMI","DIN","DFR","DGR","DCE","DMOC","SOG","FSSB","MSSB","SSB") # binary columns
yn <- c("RDM","TSP","NB","SDT","GL","SPI","NAC","GIM","GFE","MMC","BG","DHE","DCA","DPMI","DIN","DFR","DGR","DCE","DMOC","SOG") # binary columns with y/n
multiple <- c("MGS","IUCN","Modifiers", "SOC") # categorical columns with multiple options
categorical <- c(binary,multiple) # all categorical columns

for (i in 1:ncol(data_full)) { # looping through all the columns to format each one correctly
  col <- colnames(data_full)[i] # getting the name of the column we're working on
  data_full[[col]] <- gsub("#N/A","",data_full[[col]]) # replacing any of the "#N/A" generated by excel with ""
  data_full[[col]] <- gsub("^$",NA,data_full[[col]]) # replacing the blank "" with NA
  if (col %in% quantitative) {data_full[[col]] <- as.numeric(data_full[[col]])} # formatting quantitative columns as numeric
  if (col %in% yn) {data_full[[col]] <- gsub("Y","1",data_full[[col]]); data_full[[col]] <- gsub("N","0",data_full[[col]])} # swapping y/n for 1/0
  if (col %in% categorical) {data_full[[col]] <- as.factor(data_full[[col]])} # formatting all categorical columns as factors
}
```

```{r make_tree, echo=TRUE}
# This code chunk reads our giant list of trees and combines them to make one "best" tree
# We want to see this code (echo=TRUE), but we don't want to run it every time we do our analyses (it takes a while)
ANALYSIS <- "MCMCTREE"; if (USEGLOBAL) {set_global()}
if (ANALYSIS == "MCCTREE") {
  print("Generating MCC tree...",quote=F)
  trees <- ape::read.nexus("../data/phylogeny.nex")
  phy_mcc <- phangorn::maxCladeCred(trees) # Generates a maximum clade credibility (best) tree from the 1000 trees
  cat(paste0("Is Ultrametric? ", ape::is.ultrametric(phy_mcc)))
  cat(paste0("Is Bifurcating? ", castor::is_bifurcating(phy_mcc)))
  n_taxa <- length(phy_mcc$tip.label) # Gets the number of species from looking at the tip labels
  phy_mcc$node.label <- c((n_taxa + 1):(n_taxa + phy_mcc$Nnode)) # Gives number labels to nodes
  ape::write.tree(phy_mcc,"../data/mcc_tree.txt") # Saves this tree to a file called "mcc_tree.txt"
}
```

```{r read_tree, eval=TRUE}
# This code chunk reads in the full set of trees
# It also reads in our MCC tree (one best tree)

print("Reading trees...",quote=F)
phy_mcc <- ape::read.tree("../data/mcc_tree.txt") # Reads our MCC tree from a file
n_taxa <- length(phy_mcc$tip.label)
n_node <- phy_mcc$Nnode

phy_all <- ape::read.nexus("../data/phylogeny.nex") # Reads our posterior sample of trees from a file
# Giving number labels to nodes in all 1000 phylogenies
for (i in 1:length(phy_all)) {
  phy_all[[i]]$node_label <- c((n_taxa + 1):(n_taxa + n_node))
}
```

```{r phylogeny, eval=TRUE}
# This code chunk chooses a phylogeny to use with our current analysis
# There are two options: use the MCC tree, or use a random tree

print("Choosing tree...",quote=F)
phy_full <- phy_mcc # This is the default behavior
tree_number <- "TREEMCC"
# If we want a random tree instead, we do this
if (USERANDOM == TRUE) {
  num <- sample(1:1000,1)
  phy_full <- phy_all[[num]]
  tree_number <- paste0("TREE",num)
}

# Renaming or removing Phylacine species that do not match our dataset
phylogeny_changes <- read.csv("../data/Dataset_to_Phylogeny_Changes.csv", header = TRUE, sep = ",")[,1:2]
for (i in 1:nrow(phylogeny_changes)) {
  if (phylogeny_changes$Name.used.for.Phylacine[i] != "NLV") {
    new_name <- phylogeny_changes$X1700.Species.Name[i]
    old_name <- phylogeny_changes$Name.used.for.Phylacine[i]
    phy_idx <- which(phy_full$tip.label==old_name)
    phy_full$tip.label[phy_idx] <- new_name
  }
}
print(paste0("Chosen tree: ",tree_number),quote=F)
```

These species are in the dataset but not in the tree.

```{r get_mismatches}
# This code checks for all the species that are in the data but not in the tree
print("Checking for mismatched species...",quote=F)
ANALYSIS <- "SPECMATS"; if (USEGLOBAL) {set_global()}
if (ANALYSIS == "SPECMATS") {
  LON <- data_full$Species # Reduces species from my data to LON ("List of Names")
  check <- LON[which(!(LON %in% phy_full$tip.label))] # Lists species which are in mine that are not in theirs (species to check)
  print(paste0("Species to check: ",paste(check,collapse=", ")),quote=F) # Prints out the list of species that need to be checked
}
```

```{r specmats, eval=TRUE, results="SHOW"}
# This code chunk makes sure our species data and our phylogeny have the same taxa in them
# We will use this smaller tree (phy) for most of our analyses

print("Getting tree subset...",quote=F)
LON <- data_full$Species # Reduces species from my data to LON ("List of Names")
SPECMATS <- LON[which((LON %in% phy_full$tip.label))] # Creates a variable SPECMATS for all the species of mine which match those in the full trees
phy <- ape::keep.tip(phy_full, SPECMATS) # Creates a new tree reducing phy to just SPECMATS, can then plot this with plot.phylo(SPECMATSTREE)
print(paste0("Total species: ",length(phy$tip.label)),quote=F) # Prints out the number of species in the tree

# Read tree and verify ultrametric, form matrix for evolution time
inv.phylo <- inverseA(phy, "TIPS")$Ainv

# THIS SHOULD NOT BE REQUIRED ONCE ALL OF THE NAMES MATCH!!!
data <- data_full[which((LON %in% phy$tip.label)),] # Creates dataset of SPECMATS (rows that match with the tree).
```

Here is the phylogeny that we are using, only including taxa which are in the species dataset.

```{r plot_tree, eval=TRUE, results="SHOW", fig.align="center", fig.width=12, fig.height=12}
phytools::plotTree(phy, type="fan", fsize=.5, asp=1) # This plots the tree that we are using (with only matching taxa) as a circle phylogeny
```

<!--
##############################
##############################
MATERNAL INVESTMENT HYPOTHESES
##############################
##############################
-->

## Maternal Investment

### Hypothesis: 
Species with greater maternal investment need to allocate more resources to reproductively fruitful mating, and are thus less likely to exhibit SSB.

Covariates:

↑ in factor associated with ↑ in SSB: Alloparental Care (NAC), Progeny Count (PC), Paternal Investment (SPI)

↑ in factor associated with ↓ in SSB: Gestation Period (GP), Wean Age (FWA), Birth Mass to Maternal Mass Ratio (MR), Typically Single Progeny (TSP)

---

#### MCMCGLMM

```{r MI_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Maternal investment variables. Individual binary variables each get their own suite of pagels below.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "MI"; SSBTYPE <- "SSB"; if (USEGLOBAL) {set_global()}
f <- SSB ~ NAC + PC + SPI + GP + FWA + MR + TSP + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "MI" & SSBTYPE == "SSB") {do_mcmc(f)}
```

```{r MI_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_SSB_MI_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

```{r MIf_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Maternal investment variables. Individual binary variables each get their own suite of pagels below.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "MI"; SSBTYPE <- "FSSB"; if (USEGLOBAL) {set_global()}
f <- FSSB ~ NAC + PC + SPI + GP + FWA + MR + TSP + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "MI" & SSBTYPE == "FSSB") {do_mcmc(f)}
```

```{r MIf_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_FSSB_MI_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

```{r MIm_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Maternal investment variables. Individual binary variables each get their own suite of pagels below.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "MI"; SSBTYPE <- "MSSB"; if (USEGLOBAL) {set_global()}
f <- MSSB ~ NAC + PC + SPI + GP + FWA + MR + TSP + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "MI" & SSBTYPE == "MSSB") {do_mcmc(f)}
```

```{r MIm_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_MSSB_MI_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

---

#### Pagel's Directional Test

##### NAC

SSB vs. NAC

```{r  NAC_pagel, echo=TRUE}
ANALYSIS <- "PAGEL"; VARIABLE <- "NAC"; SSBTYPE <- "SSB"; if (USEGLOBAL) {set_global()}
if (ANALYSIS == "PAGEL" & VARIABLE == "NAC" & SSBTYPE == "SSB") {do_pagel()}
```

```{r NAC_pagel_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/PAGEL_SSB_NAC_TREEMCC_1.sum.txt")
cat(file_contents[(length(file_contents)-5):length(file_contents)], sep = "\n")
```

FSSB vs. NAC

```{r  NACf_pagel, echo=TRUE}
ANALYSIS <- "PAGEL"; VARIABLE <- "NAC"; SSBTYPE <- "FSSB"; if (USEGLOBAL) {set_global()}
if (ANALYSIS == "PAGEL" & VARIABLE == "NAC" & SSBTYPE == "FSSB") {do_pagel()}
```

```{r NACf_pagel_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/PAGEL_FSSB_NAC_TREEMCC_1.sum.txt")
cat(file_contents[(length(file_contents)-5):length(file_contents)], sep = "\n")
```

MSSB vs. NAC

```{r  NACm_pagel, echo=TRUE}
ANALYSIS <- "PAGEL"; VARIABLE <- "NAC"; SSBTYPE <- "MSSB"; if (USEGLOBAL) {set_global()}
if (ANALYSIS == "PAGEL" & VARIABLE == "NAC" & SSBTYPE == "MSSB") {do_pagel()}
```

```{r NACm_pagel_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/PAGEL_MSSB_NAC_TREEMCC_1.sum.txt")
cat(file_contents[(length(file_contents)-5):length(file_contents)], sep = "\n")
```

---

##### SPI

SSB vs. SPI

```{r  SPI_pagel, echo=TRUE}
ANALYSIS <- "PAGEL"; VARIABLE <- "SPI"; SSBTYPE <- "SSB"; if (USEGLOBAL) {set_global()}
if (ANALYSIS == "PAGEL" & VARIABLE == "SPI" & SSBTYPE == "SSB") {do_pagel()}
```

```{r SPI_pagel_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/PAGEL_SSB_SPI_TREEMCC_1.sum.txt")
cat(file_contents[(length(file_contents)-5):length(file_contents)], sep = "\n")
```

FSSB vs. SPI

```{r  SPIf_pagel, echo=TRUE}
ANALYSIS <- "PAGEL"; VARIABLE <- "SPI"; SSBTYPE <- "FSSB"; if (USEGLOBAL) {set_global()}
if (ANALYSIS == "PAGEL" & VARIABLE == "SPI" & SSBTYPE == "FSSB") {do_pagel()}
```

```{r SPIf_pagel_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/PAGEL_FSSB_SPI_TREEMCC_1.sum.txt")
cat(file_contents[(length(file_contents)-5):length(file_contents)], sep = "\n")
```

MSSB vs. SPI

```{r  SPIm_pagel, echo=TRUE}
ANALYSIS <- "PAGEL"; VARIABLE <- "SPI"; SSBTYPE <- "MSSB"; if (USEGLOBAL) {set_global()}
if (ANALYSIS == "PAGEL" & VARIABLE == "SPI" & SSBTYPE == "MSSB") {do_pagel()}
```

```{r SPIm_pagel_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/PAGEL_MSSB_SPI_TREEMCC_1.sum.txt")
cat(file_contents[(length(file_contents)-5):length(file_contents)], sep = "\n")
```

---

##### TSP

SSB vs. TSP

```{r  TSP_pagel, echo=TRUE}
ANALYSIS <- "PAGEL"; VARIABLE <- "TSP"; SSBTYPE <- "SSB"; if (USEGLOBAL) {set_global()}
if (ANALYSIS == "PAGEL" & VARIABLE == "TSP" & SSBTYPE == "SSB") {do_pagel()}
```

```{r TSP_pagel_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/PAGEL_SSB_TSP_TREEMCC_1.sum.txt")
cat(file_contents[(length(file_contents)-5):length(file_contents)], sep = "\n")
```

FSSB vs. TSP

```{r  TSPf_pagel, echo=TRUE}
ANALYSIS <- "PAGEL"; VARIABLE <- "TSP"; SSBTYPE <- "FSSB"; if (USEGLOBAL) {set_global()}
if (ANALYSIS == "PAGEL" & VARIABLE == "TSP" & SSBTYPE == "FSSB") {do_pagel()}
```

```{r TSPf_pagel_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/PAGEL_FSSB_TSP_TREEMCC_1.sum.txt")
cat(file_contents[(length(file_contents)-5):length(file_contents)], sep = "\n")
```

MSSB vs. TSP

```{r  TSPm_pagel, echo=TRUE}
ANALYSIS <- "PAGEL"; VARIABLE <- "TSP"; SSBTYPE <- "MSSB"; if (USEGLOBAL) {set_global()}
if (ANALYSIS == "PAGEL" & VARIABLE == "TSP" & SSBTYPE == "MSSB") {do_pagel()}
```

```{r TSPm_pagel_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/PAGEL_MSSB_TSP_TREEMCC_1.sum.txt")
cat(file_contents[(length(file_contents)-5):length(file_contents)], sep = "\n")
```

<!--
####################
####################
SOCIALITY HYPOTHESES
####################
####################
-->

## Sociality

### Hypothesis 1: 
Social species whose group structure involves increased time spent exclusively with the same sex will route more sexual behavior to same-sex interactions.

Tested covariates:

↑ in group type associated with ↑ in SSB: MBG, HBG, FEG, SSG

↑ in group type associated with ↓ in SSB: SOL, MOP, HAR, MMG, HVG

---

#### MCMCGLMM

```{r MGS_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Sociality variables.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "MGS"; SSBTYPE <- "SSB"; if (USEGLOBAL) {set_global()}
f <- SSB ~ MGS + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "MGS" & SSBTYPE == "SSB") {do_mcmc(f)}
```

```{r MGS_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_SSB_MGS_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

```{r MGSf_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Sociality variables.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "MGS"; SSBTYPE <- "FSSB"; if (USEGLOBAL) {set_global()}
f <- FSSB ~ MGS + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "MGS" & SSBTYPE == "FSSB") {do_mcmc(f)}
```

```{r MGSf_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_FSSB_MGS_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

```{r MGSm_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Sociality variables.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "MGS"; SSBTYPE <- "MSSB"; if (USEGLOBAL) {set_global()}
f <- MSSB ~ MGS + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "MGS" & SSBTYPE == "MSSB") {do_mcmc(f)}
```

```{r MGSm_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_MSSB_MGS_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

### Hypothesis 2: 
Territorial animals are more likely to exhibit SSB as a means of mitigating the risk of fatal conspecific violence.

Tested covariates:

↑ in factor associated with ↑ in SSB: Territoriality

Note: The Nature paper that plotted out the phylogeny of SSB demonstrated that SSB often evolves subsequently to male adulticide, which they attributed to SSB potentially acting as a means of mitigation that allows for aggression release without necessitating more violence. This hypothesis is trying to build on that, which is why it doesn’t match the “Darwinian Paradox” approach of the others.

---

#### MCMCGLMM

```{r SDT_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Territoriality variables. Individual binary variables each get their own suite of pagels below.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "SDT"; SSBTYPE <- "SSB"; if (USEGLOBAL) {set_global()}
f <- SSB ~ SDT + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "SDT" & SSBTYPE == "SSB") {do_mcmc(f)}
```

```{r SDT_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_SSB_SDT_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

```{r SDTf_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Territoriality variables. Individual binary variables each get their own suite of pagels below.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "SDT"; SSBTYPE <- "FSSB"; if (USEGLOBAL) {set_global()}
f <- FSSB ~ SDT + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "SDT" & SSBTYPE == "FSSB") {do_mcmc(f)}
```

```{r SDTf_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_FSSB_SDT_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

```{r SDTm_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Territoriality variables. Individual binary variables each get their own suite of pagels below.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "SDT"; SSBTYPE <- "MSSB"; if (USEGLOBAL) {set_global()}
f <- MSSB ~ SDT + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "SDT" & SSBTYPE == "MSSB") {do_mcmc(f)}
```

```{r SDTm_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_MSSB_SDT_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

---

#### Pagel's Directional Test

SSB vs. SDT

```{r  SDT_pagel, echo=TRUE}
ANALYSIS <- "PAGEL"; VARIABLE <- "SDT"; SSBTYPE <- "SSB"; if (USEGLOBAL) {set_global()}
if (ANALYSIS == "PAGEL" & VARIABLE == "SDT" & SSBTYPE == "SSB") {do_pagel()}
```

```{r SDT_pagel_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/PAGEL_SSB_SDT_TREEMCC_1.sum.txt")
cat(file_contents[(length(file_contents)-5):length(file_contents)], sep = "\n")
```

FSSB vs. SDT

```{r  SDTf_pagel, echo=TRUE}
ANALYSIS <- "PAGEL"; VARIABLE <- "SDT"; SSBTYPE <- "FSSB"; if (USEGLOBAL) {set_global()}
if (ANALYSIS == "PAGEL" & VARIABLE == "SDT" & SSBTYPE == "FSSB") {do_pagel()}
```

```{r SDTf_pagel_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/PAGEL_FSSB_SDT_TREEMCC_1.sum.txt")
cat(file_contents[(length(file_contents)-5):length(file_contents)], sep = "\n")
```

MSSB vs. SDT

```{r  SDTm_pagel, echo=TRUE}
ANALYSIS <- "PAGEL"; VARIABLE <- "SDT"; SSBTYPE <- "MSSB"; if (USEGLOBAL) {set_global()}
if (ANALYSIS == "PAGEL" & VARIABLE == "SDT" & SSBTYPE == "MSSB") {do_pagel()}
```

```{r SDTm_pagel_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/PAGEL_MSSB_SDT_TREEMCC_1.sum.txt")
cat(file_contents[(length(file_contents)-5):length(file_contents)], sep = "\n")
```

### Hypothesis 3: 
Solitary species that demonstrate occasional grouping are more likely to have same-sex interactions than purely solitary species, and are thus more likely to exhibit SSB. Monogamous pairs and small family units are not considered groups on their own.

Tested covariates:

↑ in factor associated with ↑ in SSB: Occasional Groupings in Solitary Species.

Note: The same Nature paper already established that social species are associated with ↑ SSB, so this extends that to a deeper analysis of solitary species.

---

#### MCMCGLMM

```{r SOC_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Territoriality variables. Individual binary variables each get their own suite of pagels below.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "SOC"; SSBTYPE <- "SSB"; if (USEGLOBAL) {set_global()}
f <- SSB ~ SOC + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "SOC" & SSBTYPE == "SSB") {do_mcmc(f)}
```

```{r SOC_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_SSB_SOC_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

```{r SOCf_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Territoriality variables. Individual binary variables each get their own suite of pagels below.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "SOC"; SSBTYPE <- "FSSB"; if (USEGLOBAL) {set_global()}
f <- FSSB ~ SOC + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "SOC" & SSBTYPE == "FSSB") {do_mcmc(f)}
```

```{r SOCf_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_FSSB_SOC_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

```{r SOCm_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Territoriality variables. Individual binary variables each get their own suite of pagels below.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "SOC"; SSBTYPE <- "MSSB"; if (USEGLOBAL) {set_global()}
f <- MSSB ~ SOC + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "SOC" & SSBTYPE == "MSSB") {do_mcmc(f)}
```

```{r SOCm_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_MSSB_SOC_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

<!--
####################################
####################################
CONFUSION & MALADAPTATION HYPOTHESES
####################################
####################################
-->

## Confusion & Maladaptation

### Hypothesis 1: 
Species with notably dimorphic external morphology (excluding sex organs) are less likely to confuse members of the same and opposite sex, and are therefore less likely to exhibit SSB.

Tested covariates:

↑ in factor associated with ↓ in SSB: Radically Dimorphic Morphology

---

#### MCMCGLMM

```{r RDM_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Confusion variables. Individual binary variables each get their own suite of pagels below.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "RDM"; SSBTYPE <- "SSB"; if (USEGLOBAL) {set_global()}
f <- SSB ~ RDM + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "RDM" & SSBTYPE == "SSB") {do_mcmc(f)}
```

```{r RDM_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_SSB_RDM_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

```{r RDMf_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Confusion variables. Individual binary variables each get their own suite of pagels below.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "RDM"; SSBTYPE <- "FSSB"; if (USEGLOBAL) {set_global()}
f <- FSSB ~ RDM + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "RDM" & SSBTYPE == "FSSB") {do_mcmc(f)}
```

```{r RDMf_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_FSSB_RDM_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

```{r RDMm_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Confusion variables. Individual binary variables each get their own suite of pagels below.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "RDM"; SSBTYPE <- "MSSB"; if (USEGLOBAL) {set_global()}
f <- MSSB ~ RDM + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "RDM" & SSBTYPE == "MSSB") {do_mcmc(f)}
```

```{r RDMm_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_MSSB_RDM_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

---

#### Pagel's Directional Test

SSB vs. RDM

```{r  RDM_pagel, echo=TRUE}
ANALYSIS <- "PAGEL"; VARIABLE <- "RDM"; SSBTYPE <- "SSB"; if (USEGLOBAL) {set_global()}
if (ANALYSIS == "PAGEL" & VARIABLE == "RDM" & SSBTYPE == "SSB") {do_pagel()}
```

```{r RDM_pagel_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/PAGEL_SSB_RDM_TREEMCC_1.sum.txt")
cat(file_contents[(length(file_contents)-5):length(file_contents)], sep = "\n")
```

FSSB vs. RDM

```{r  RDMf_pagel, echo=TRUE}
ANALYSIS <- "PAGEL"; VARIABLE <- "RDM"; SSBTYPE <- "FSSB"; if (USEGLOBAL) {set_global()}
if (ANALYSIS == "PAGEL" & VARIABLE == "RDM" & SSBTYPE == "FSSB") {do_pagel()}
```

```{r RDMf_pagel_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/PAGEL_FSSB_RDM_TREEMCC_1.sum.txt")
cat(file_contents[(length(file_contents)-5):length(file_contents)], sep = "\n")
```

MSSB vs. RDM

```{r  RDMm_pagel, echo=TRUE}
ANALYSIS <- "PAGEL"; VARIABLE <- "RDM"; SSBTYPE <- "MSSB"; if (USEGLOBAL) {set_global()}
if (ANALYSIS == "PAGEL" & VARIABLE == "RDM" & SSBTYPE == "MSSB") {do_pagel()}
```

```{r RDMm_pagel_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/PAGEL_MSSB_RDM_TREEMCC_1.sum.txt")
cat(file_contents[(length(file_contents)-5):length(file_contents)], sep = "\n")
```

### Hypothesis 2:
Species with higher ages of maturity are more likely to observe SSB while young and try to replicate same-sex sexual interactions upon reaching adulthood.

Tested covariates:

↑ in factor associated with ↑ in SSB: Male Age of Maturity, Female Age of Maturity.

---

#### MCMCGLMM

```{r AM_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Maturity variables.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "AM"; SSBTYPE <- "SSB"; if (USEGLOBAL) {set_global()}
f <- SSB ~ FAM + MAM + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "AM" & SSBTYPE == "SSB") {do_mcmc(f)}
```

```{r AM_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_SSB_AM_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

```{r AMf_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Maturity variables.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "AM"; SSBTYPE <- "FSSB"; if (USEGLOBAL) {set_global()}
f <- FSSB ~ FAM + MAM + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "AM" & SSBTYPE == "FSSB") {do_mcmc(f)}
```

```{r AMf_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_FSSB_AM_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

```{r AMm_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our Maturity variables.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "AM"; SSBTYPE <- "MSSB"; if (USEGLOBAL) {set_global()}
f <- MSSB ~ FAM + MAM + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "AM" & SSBTYPE == "MSSB") {do_mcmc(f)}
```

```{r AMm_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_MSSB_AM_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

### Hypothesis 3: 
SSB is an energy intensive but reproductively unfruitful endeavor, and will therefore be associated with reduced species success.

Tested covariates:

↑ in SSB associated with ↑ in factor: High IUCN Endangerment Status, Extinction Rate.

↑ in SSB associated with ↓ in factor: Diversification.

---

#### MCMCGLMM

```{r IUCN_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our IUCN variables.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "IUCN"; SSBTYPE <- "SSB"; if (USEGLOBAL) {set_global()}
f <- SSB ~ IUCN + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "IUCN" & SSBTYPE == "SSB") {do_mcmc(f)}
```

```{r IUCN_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_SSB_IUCN_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

```{r IUCNf_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our IUCN variables.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "IUCN"; SSBTYPE <- "FSSB"; if (USEGLOBAL) {set_global()}
f <- FSSB ~ IUCN + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "IUCN" & SSBTYPE == "FSSB") {do_mcmc(f)}
```

```{r IUCNf_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_FSSB_IUCN_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

```{r IUCNm_mcmcglmm, echo=TRUE}
#Runs MCMCglmm for all our IUCN variables.
ANALYSIS <- "MCMCGLMM"; HYPOTHESIS <- "IUCN"; SSBTYPE <- "MSSB"; if (USEGLOBAL) {set_global()}
f <- MSSB ~ IUCN + 1
if (ANALYSIS == "MCMCGLMM" & HYPOTHESIS == "IUCN" & SSBTYPE == "MSSB") {do_mcmc(f)}
```

```{r IUCNm_mcmcglmm_show, eval=TRUE, results="SHOW"}
file_contents <- readLines("output/MCMCGLMM_MSSB_IUCN_TREEMCC_1.sum.txt")
cat(file_contents, sep = "\n")
```

<!--
#############################
#############################
EXAMPLE ANALYSIS OF EACH TYPE
#############################
#############################
-->

## Example Analyses

### Correlations

This analysis determines whether factors are significantly correlated with SSB, either via a chi-square test (categorical factors) or a t-test (quantitative factors). These tests do not incorporate phylogeny and are only used as a preliminary check for whether each factor should be analyzed more deeply.

```{r correlations, echo=TRUE}
# This code chunk assesses how each independent variable correlates with SSB
# It prints out each statistical test, and also creates a file called "correlations.csv" that documents them
# Here we use results="hold" to tell R markdown to put all the output in one section

SSB <- data$SSB

tests <- data.frame(matrix(NA,ncol=3,nrow=0)) # This matrix will hold the results of our statistical tests for correlations
for (name in colnames(data)) { # We want to look at all the independent variables and check whether they are correlated with SSB
  if (name %in% categorical) { # Checking if this is a categorical variable
    ind <- data[[name]] # Getting the data from the column
    test <- suppressWarnings(chisq.test(x=SSB,y=ind)$p.value) # Performing a chi-square test of significance and getting the p-value from it
    if (test <= 0.05) { # Checks if the p-value is significant - if yes, do the next thing
      row <- c(name=name,p=test,keep="Y") # Recording "Y" in the "keep" column if the test shows significance
    } else { # If the p-value was not significant, do this instead
      row <- c(name=name,p=test,keep="N") # Recording "N" in the "keep" column if the test does not show significance
    }
    tests <- rbind(tests,row) # Adding the results of this test (for this variable) to the list of tests for all variables
    cat(paste0("\nVariable: ",gsub("."," ",row[1],fixed=TRUE)," | p = ",round(as.numeric(row[2]),4)," | Significant: ",row[3]),"\n") # Printing the statistical test being performed
    print(suppressWarnings(chisq.test(x=SSB,y=ind)$observed)) # Printing the details of this statistical test
  }
  if (name %in% quantitative) { # Checking if this is a quantitative variable
    ind <- data[[name]] # Getting the data from the column
    test <- suppressWarnings(t.test(ind ~ SSB, data=cbind(SSB,ind),na.rm=TRUE)$p.value) # Performing a t-test of significance and getting the p-value from it
    if (test <= 0.05) { # Checks if the p-value is significant - if yes, do the next thing
      row <- c(name=name,p=test,keep="Y") # Recording "Y" in the "keep" column if the test shows significance
    } else { # If the p-value was not significant, do this instead
      row <- c(name=name,p=test,keep="N") # Recording "N" in the "keep" column if the test does not show significance
    }
    tests <- rbind(tests,row) # Adding the results of this test (for this variable) to the list of tests for all variables
    cat(paste0("\nVariable: ",gsub("."," ",row[1],fixed=TRUE)," | p = ",round(as.numeric(row[2]),4)," | Significant: ",row[3]),"\n") # Printing the statistical test being performed
    print(suppressWarnings(t.test(ind ~ SSB, data=cbind(SSB,ind),na.rm=TRUE)$estimate)) # Printing the details of this statistical test
  }
}

colnames(tests) <- c("name","p","keep") # Naming the columns for our dataframe with all the statistical test results
write.csv(tests,"correlations.csv",quote=FALSE,sep=",",row.names=FALSE,col.names=TRUE) # Saving our statistical tests to a file
```

### Phylogenetic Signal

In this analysis, we are checking whether a particular binary trait shows phylogenetic signal. Essentially, do species which are more closely related show traits that are more similar? If d=1, this indicates that they do not (no phylogenetic signal) -- basically, the trait is totally random on the tree. Otherwise, the trait shows phylogenetic signal. The test also shows whether the trait follows a Brownian model, where trait similarity is based on the amount of time species spend evolving together. If d=0, this indicates that the trait follows a Brownian model. If d>0 (but d<1), this indicates that species are more different than expected under a Brownian model, while d<0 indicates that they are more similar.


```{r signal, echo=TRUE}
# This code chunk conducts a test for phylogenetic signal (d) using the "caper" package
# d=1 indicates complete randomness of trait (no phylogenetic signal), all rest have phylogenetic signal
# d=0 trait follows Brownian, d positive under 1 more different than Brownian, d negative more similar than Brownian

caper::phylo.d(data, phy, Species, SSB) # Tests for phylogenetic signal in SSB, shows more differentiation than expected under Brownian structure
caper::phylo.d(data, phy, Species, FSSB) #same analysis for female SSB. Positive D shows more differentiation between species than expected.
caper::phylo.d(data, phy, Species, MSSB) #same analysis for male SSB. Positive D shows more differentiation between species than expected.
caper::phylo.d(data, phy, Species, TSP) # Tests for phylogenetic signal in typically single progeny, shows Brownian structure
```

### Transition Rates

In this analysis, we are estimating transition rates between different combinations of traits (in this case, combinations of FSSB and TSP) based on a model that we define. We decide which rates are allowed to be different from one another, and then estimate rates under that model. This is somewhat different from Pagel's directional test, which compares multiple models (matrices of rate parameters) to see which one best describes the data. When we run Pagel's directional test we are also doing this, so we don't have to run this analysis separately.

```{r ard, echo=TRUE}
# This code chunk does an ancestral character estimation (ACE) for SSB using the "ape" package
# It also determines the rates of transition between different characters / sets of characters
# We use a CTMC to determine relationship between different variable in a matrix

dataAFSSBmtrx <- matrix(c(0, 1, 2, 0),2) # Forms matrix for future use by AFSSB
dataAFSSB <- ape::ace(data$SSB,phy, type = "discrete", model = dataAFSSBmtrx) # Reconstructed ancestral states of SSB

for (i in 1:nrow(data)) { # Create for loop for finding four states of dual relation between FSSB and TSP
  dataifFSSB <- data$SSB[i]
  dataifTSP <- data$TSP[i]
  if (dataifFSSB == 0) {
    if (dataifTSP == 0) {
      state <- 1 # no FSSB, no TSP
    } else {
      state <- 2 # no FSSB, yes TSP
    }
  }else {
  if (dataifTSP == 0) {
      state <- 3 # yes FSSB, no TSP
    } else {
      state <- 4 # yes FSSB, yes TSP
    }
  }
  data$FSSB_TSP[i] <- state # Takes new state info and adds it as a row to data named FSSB_TSP
}

dataAFSSB_TSPmtrx <- matrix(c(0, 1, 2, 0, 3, 0, 0, 4, 5, 0, 0, 6, 0, 7, 8, 0),4, byrow=TRUE) # Forms matrix for use in FSSB_TSP rate estimates, manually adjusted 0 terms for things we determine impossible
dataAFSSB_TSP <- ape::ace(data$FSSB_TSP, phy, type = "discrete", model = dataAFSSB_TSPmtrx) # Generates rate matrix for AFSSB_TSP
print(dataAFSSB_TSP)
```

In this analysis, we are comparing multiple models (matrices of rate parameters) to see which one best describes the data. We will compare 4 models:

1. SSB and TSP evolve independently of one another
2. SSB depends on TSP
3. TSP depends on SSB
4. Both SSB and TSP depend on one another

```{r pagel, echo=TRUE}
# This code chunk does pagel's directional test
# Pagel's directional test: http://www.phytools.org/Cordoba2017/ex/9/Pagel94-method.html
# These take a long time to run, so don't be worried if results don't print immediately

if (RERUN) {
  FSSB <- setNames(data$FSSB,data$Species) # Naming our FSSB values with species names
  TSP <- setNames(data$TSP,data$Species) # Naming our TSP values with species names
  
  fit_FSSB_TSP <- phytools::fitPagel(phy,FSSB,TSP) # Fitting models where FSSB and TSP are totally independent or dependent
  fit_FSSB_TSP
  plot(fit_FSSB_TSP,lwd.by.rate=TRUE)
  
  fit_FSSB <- phytools::fitPagel(phy,FSSB,TSP,dep.var="x") # Fitting models where FSSB depends on TSP
  fit_FSSB
  plot(fit_FSSB,lwd.by.rate=TRUE)
  
  fit_TSP <- phytools::fitPagel(phy,FSSB,TSP,dep.var="y") # Fitting models where TSP depends on FSSB
  fit_TSP
  plot(fit_TSP,lwd.by.rate=TRUE)
  
  # Comparing the goodness of all 4 models using AIC
  aic <- setNames(c(fit_FSSB_TSP$independent.AIC,
                    fit_FSSB$dependent.AIC,
                    fit_TSP$dependent.AIC,
                    fit_FSSB_TSP$dependent.AIC),
                  c("independent","dependent FSSB","dependent TSP","dependent FSSB & TSP"))
  aic
  aic.w(aic)
}
```

### MCMCglmm

This analysis determines how a collection of independent variables contribute to a dependent variable (in this case, SSB). It creates a function where SSB is a function of several variables, and the coefficients of those variables tell us whether the variable is significantly related to SSB. If the quantiles for a particular coefficient exclude 0, then the variable is significant. The sign of the coefficient tells us the direction of the relationship (positive = increased SSB, negative = decreased SSB).

```{r mcmcglmm, echo=TRUE}
# This code chunk runs an MCMCglmm analysis

if (RERUN) {
  data_subset <- data[,c("Species","TSP","SSB","FSSB","MSSB")]
  data_subset <- data_subset[complete.cases(data_subset),] # Removes incomplete cases (NAs)
  print(data_subset) # Prints that data
  
  # Reads a tree and makes sure all tips are exactly at the present (ultrametric)
  # Then creates a matrix for how much time species pairs have spent evolving together vs separately
  inv.phylo <- inverseA(phy, "TIPS")$Ainv
  
  # Makes these things called priors, which are prior assumptions on variance distribution for the following model
  prior <- list(G=list(G1=list(V=1,nu=0.02)), # This is the prior on random effects, i.e. Species identity -- small nu means mostly flat
                R=list(V=1,nu=0.02))          # This is the prior on your response variable, i.e. SSB -- small nu means mostly flat
  
  # Runs MCMCglmm fancy linear regression analysis
  MCMCanalysis <- MCMCglmm::MCMCglmm(SSB~TSP+1, # Formula for analysis: SSB is related to TSP, PC, and some intercept
                  random = ~Species, # Random effect -- species identity is a confounding factor in the analysis
                  family = "categorical", # Our response variable is categorical
                  ginverse = list(Species=inv.phylo), # These are our phylogenetic relationships, which cause covariance structure
                  prior = prior, # Telling the MCMC what our priors are
                  data = data_subset, # Telling the MCMC what our data is
                  nitt = 1000, # The number of iterations, i.e. samples, should do more for a real analysis
                  burnin = 100, # How long the MCMC spends "optimizing" before real samples
                  thin = 1, # How often to print output (every 1)
                  verbose = FALSE) # Don't write out too much stuff
  
  print(summary(MCMCanalysis$Sol))
}
```

### SSE

This analyses determines whether a particular binary trait (in this case, SSB) is associated with different rates of speciation and extinction. This is a simple model that only uses one binary trait, but better models also have "hidden" states. These hidden states are not observed traits of the organisms, but allow rates to be different on different parts of the tree due to unobserved factors. SSE analyses (and other phylogenetic analyses) are sensitive to the sampling fraction, i.e. the number of taxa in the dataset compared to how many species are actually in the group. We should do some research to determine whether there are appropriate ways to handle this.

```{r sse, echo=TRUE}
# This code chunk runs a bisse analysis on just the taxa included in our dataset
# We don't want this to run every time we knit -- only when we manually want to run it
# To prevent us from running accidentally, we have RERUN <- FALSE at the start of the script
# We have to manually type RERUN <- TRUE for this to run
# We will save the MCMC to a file and have a separate code chunk to print a summary

if (RERUN) {
  states <- as.numeric(as.character(data$SSB)) # We need to make our SSB into a number instead of a factor for this analysis
  names(states) <- data$Species # diversitree requires us to name our states with species names
  lik <- diversitree::make.bisse(phy, states) # This is our bisse model, with our tree and tip states
  pars <- c(0.1, 0.1, 0.01, 0.01, 0.01, 0.01) # lambda 0 and 1 (speciation), mu 0 and 1 (extinction), q 01 and 10 (transition) initial values
  n_iter <- 100 # The number of MCMC iterations, i.e. samples (will use more for a real analysis)
  burnin <- 20 # The number of burnin iterations, i.e. how long we spend "optimizing" before real samples
  
  # Our MCMC analysis
  # Our tuning parameter (for MCMC proposals) is 0.1
  # We want to print to screen every 10 iterations
  MCMCanalysis <- diversitree::mcmc(lik, pars, nsteps=n_iter, w=0.1, print.every=10)
  MCMCresults <- MCMCanalysis[burnin:n_iter,] # Removing burnin iterations
  write.table(MCMCresults,"bisse.tsv",quote=FALSE,sep="\t",row.names=FALSE,col.names=TRUE) # Saving our MCMC output to a file
  
  RERUN <- FALSE
}
```

```{r sse_show, echo=TRUE}
MCMCresults <- read.csv("bisse.tsv",sep="\t") # Retrieving our MCMC results from the bisse.csv file
MCMCsummary <- MCMCvis::MCMCsummary(coda::mcmc(MCMCresults),excl=c("i","p"),Rhat=FALSE,round=4) # Turning into MCMC object and summarizing output (excluding iteration and probability)
print(MCMCsummary)
```